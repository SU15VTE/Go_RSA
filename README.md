# Go_RSA
# 实验四
## 算法的实现
### 密钥的生成
1.首先我们生成两个素数：p和q

2.然后我们再计算n和φ(n)
**n=p*q**

**φ(n) = (p-1)*(q-1)**

3.然后我们取一个随机数e,e要满足
**1 < e <φ(n)**

4.有了e和φ(n)，我们就可以计算d了
**d * e ≡ 1 (mod φ(n))**

经过上面4轮操作，我们就能得到公钥(n,e)和私钥(n,d)了。这里我们没有对密钥进行处理，将它转换为PEM格式。因为这很麻烦，而且也不是本章的重点，我们侧重点是了解RSA加密的过程。


## 加密解密过程
加密：**(planinText ** e )mod n**
解密：**(cipherText ** d )mod n**

# 需要注意的问题
## 大素数的计算
这里我们生成的 p和q,一般都是较大的素数。而我们的处理器一般能存储32位或64位的整数，(更早的处理器，拿Intel 8086为例，它的处理器是16位的，只能存储16位的整数)，而64位的整数对大素数的计算而言是远远不够的，这就要引入我们的  **math/big** 包了，big包是Golang标准库提供的一个高精度数学运算库。它实现了大整数的基本运算，例如加、减、乘、除、取模、比较等。其实现原理是通过底层的二进制位运算实现大整数的高精度运算。
在实现高精度数学运算时，我们通常会采用字符串或数组存储大整数。然而，这种存储方式会占用较多的内存，并且在实现运算时效率较低。因此，big包采用了更为高效的存储方式，即使用 uint64 类型的 slice 存储大整数的每一位。在进行高精度运算时，big包还采用了 Karatsuba 算法和 Toom-Cook 算法等高效的算法，以提高计算效率。同时，big包还提供了基于 OpenSSL 库的加密算法，例如 RSA 算法、DSA 算法等，因此我们在完成RSA算法时，能直接调用它包中封装好的算法，如 
``` golang
func (z *Int) ModInverse(g, p *Int) *Int 
//将z设为g相对p的模逆（即z、g满足(z * g) % p == 1）。返回值z大于0小于p。


func (z *Int) Exp(x, y, m *Int) *Int
//将z设为x**y mod |m|并返回z；如果y <= 0，返回1；如果m == nil 或 m == 0，z设为x**y。
```

而这时也要求我们进行运算的其他对象的类型也是 *big.Int类型才行，比如我们创建一个值为15的数
``` golang
a := 15		//这样写是错误的，这样生成的a为int类型，不可以和*big.Int继续运算
a := big.NewInt(15)	//我们可以通过 big.NewInt() 这个函数来生成一个 *big.Int 类型的数
```

那么这里我对 **math/big** 包做了一个简单的概述，详情可以参考这个文档(goalng标准库中文文档)[https://studygolang.com/pkgdoc]

## 对数据的加密
这里我还写多了几个函数，对字符串进行遍历，然后将字符串一个又一个加密，这样做的原因是：在RSA加密中，如果明文比密钥长度还要大，那么加密后的密文就会超过密钥长度，这个加密的结果就无效了，举个例子：
``` python3
n:3233
e:17
d:2753
PlainText:87521618088895727931649124 ("Hello World"转换为bit.Int类型，即new(big.Int).SetBytes([]byte("Hello World")))
CipherText:1647

加密：
>>> 87521618088895727931649124 ** 17 % 3233
1647

解密：
>>> 1647 ** 2753 % 3233
3050
```
这里加密的结果就是无效的。因此我们加密越长的密文，就要求我们需要的更长的密钥。但是这里要注意的是， **我们遍历字符串进行加密是不安全的**，这样我们加密一个长度为L的字符串时，我们会用同一个RSA密钥，使用多次相同的加密指数和模数加密多个明文，攻击者可以通过计算这两个密文的最大公约数来推断出加密指数，然后通过计算模数的欧拉函数来推断出私钥。

因此，我们这里还是选择生成更长的密钥，加密更长的字符串。这里遍历字符串加密的方法只是演示给一些同学看，某些同学可能使用的是C语言，而C语言的标准库中貌似没有类似于Golang中 big这的包，因此，这些同学在加密时可以选择遍历字符串这种做法，我们侧重点在于了解RSA算法的原理。但是你们一定要清楚，这种做法是不规范的，不安全的！

